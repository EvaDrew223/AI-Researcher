{
    "topic_description": "novel prompting methods that can improve factuality and reduce hallucination of large language models",
    "idea_name": "Recursive Decomposition Prompting",
    "raw_idea": {
        "Problem": "Large Language Models (LLMs) struggle with complex multi-hop reasoning tasks that require decomposing the problem into simpler sub-problems and recursively solving them. Existing methods like chain-of-thought prompting only perform single-level decomposition.",
        "Existing Methods": "Datasets like DROP and MathQA contain complex multi-hop questions. Baselines include standard prompting and chain-of-thought reasoning.",
        "Motivation": "Many real-world reasoning tasks require recursive problem decomposition. We can prompt LLMs to mimic this by generating a decomposition tree, solving sub-problems recursively, and combining partial solutions.",
        "Proposed Method": "We propose recursive decomposition prompting with three steps: 1) Decomposition: Prompt the LLM to decompose the complex problem into simpler sub-problems, forming a decomposition tree. 2) Recursive Solving: Recursively prompt the LLM to solve each sub-problem. If a sub-problem is still complex, apply decomposition prompting to it recursively. 3) Combination: Prompt the LLM to combine the partial solutions according to the decomposition tree to derive the final answer. Prompts are designed to generate the decomposition tree and sub-problem solutions in structured formats to facilitate parsing and combination.",
        "Experiment Plan": "Evaluate on multi-hop reasoning datasets like DROP and MathQA. Compare with baselines including standard prompting, chain-of-thought, and generated knowledge prompting. Metrics include accuracy and number of reasoning steps."
    },
    "full_experiment_plan": {
        "Title": "Recursive Decomposition Prompting for Complex Multi-Hop Reasoning",
        "Problem Statement": "Large Language Models (LLMs) struggle with complex multi-hop reasoning tasks that require decomposing the problem into simpler sub-problems and recursively solving them. Existing methods like chain-of-thought prompting only perform single-level decomposition.",
        "Motivation": "Many real-world reasoning tasks require recursive problem decomposition. Existing datasets like DROP and MathQA contain complex multi-hop questions that serve as good benchmarks. However, standard prompting and chain-of-thought reasoning baselines fall short on these tasks as they only do single-level decomposition. We can prompt LLMs to mimic the human problem-solving process of generating a decomposition tree, solving sub-problems recursively, and combining partial solutions. This recursive decomposition could potentially enable LLMs to tackle complex reasoning problems more effectively.",
        "Proposed Method": "We propose recursive decomposition prompting with three steps:\n1. Decomposition: Prompt the LLM to decompose the complex problem into simpler sub-problems, forming a decomposition tree.\n2. Recursive Solving: Recursively prompt the LLM to solve each sub-problem. If a sub-problem is still complex, apply decomposition prompting to it recursively.\n3. Combination: Prompt the LLM to combine the partial solutions according to the decomposition tree to derive the final answer.\nPrompts are designed to generate the decomposition tree and sub-problem solutions in structured formats to facilitate parsing and combination.",
        "Step-by-Step Experiment Plan": {
            "Step 1: Gather Datasets": "Evaluate on multi-hop reasoning datasets like DROP and MathQA. These datasets contain complex questions that require multiple reasoning steps to arrive at the answer.",
            "Step 2: Construct Prompts": "Design prompts for each step of recursive decomposition:\n1. Decomposition Prompt: Instruct the model to break down the question into sub-problems. E.g., 'Decompose the following question into sub-problems. Represent the decomposition as a tree where each node is a sub-problem. Format the tree as a nested bulleted list.'\n2. Recursive Solving Prompt: Prompt the model to solve each sub-problem. If the sub-problem is a leaf node, directly answer it. If it's a non-leaf node, apply the decomposition prompt to it. E.g., 'Solve the sub-problem: [sub-problem]. If the sub-problem is complex, first decompose it into further sub-problems.'\n3. Combination Prompt: Ask the model to combine sub-problem solutions based on the decomposition tree. E.g., 'Combine the sub-problem solutions based on the decomposition tree to derive the final answer to the original question: [original question]'",
            "Step 3: Implement Recursive Decomposition": "Write a program to apply the prompts recursively:\n1. Apply the decomposition prompt to the original question to get the decomposition tree.\n2. Traverse the decomposition tree. For each node:\n   a. If it's a leaf node, apply the solving prompt to get the sub-problem solution.\n   b. If it's a non-leaf node, recursively apply the decomposition prompt to get its decomposition sub-tree. Recursively solve the sub-tree.\n3. Apply the combination prompt to combine sub-problem solutions and get the final answer.",
            "Step 4: Select Models": "Evaluate the proposed method on large language models like GPT-3.5 and GPT-4.",
            "Step 5: Establish Baselines": "Implement baseline methods for comparison:\n1. Standard Prompting: Prompt the model with the original question directly.\n2. Chain-of-Thought Prompting: Prompt the model to solve the question step-by-step, but without explicit decomposition.\n3. Generated Knowledge Prompting: Prompt the model to generate relevant knowledge before answering the question.",
            "Step 6: Evaluate and Compare": "Evaluate the proposed recursive decomposition prompting and baselines on the gathered datasets. Use metrics like exact match accuracy and F1 score. Compare the performance of different methods. Analyze the number of reasoning steps taken by each method."
        },
        "Test Case Examples": {
            "Test Case 1": {
                "Question": "A restaurant served 2384 customers in March, and 1869 customers in April. How many more customers were served in March than in April?",
                "Baseline Prompt": "A restaurant served 2384 customers in March, and 1869 customers in April. How many more customers were served in March than in April?",
                "Baseline Output": "To find how many more customers were served in March than in April, I'll subtract the number of April customers from the number of March customers.\nMarch customers: 2384\nApril customers: 1869\n2384 - 1869 = 515\nSo the restaurant served 515 more customers in March than in April.",
                "Decomposition Prompt": "Decompose the following question into sub-problems. Represent the decomposition as a tree where each node is a sub-problem. Format the tree as a nested bulleted list.\nQuestion: A restaurant served 2384 customers in March, and 1869 customers in April. How many more customers were served in March than in April?",
                "Decomposition Output": "- Find the number of customers served in March\n- Find the number of customers served in April\n- Subtract the number of April customers from the number of March customers",
                "Recursive Solving Prompt 1": "Solve the sub-problem: Find the number of customers served in March",
                "Recursive Solving Output 1": "The number of customers served in March is 2384.",
                "Recursive Solving Prompt 2": "Solve the sub-problem: Find the number of customers served in April",
                "Recursive Solving Output 2": "The number of customers served in April is 1869.",
                "Recursive Solving Prompt 3": "Solve the sub-problem: Subtract the number of April customers from the number of March customers",
                "Recursive Solving Output 3": "2384 - 1869 = 515",
                "Combination Prompt": "Combine the sub-problem solutions based on the decomposition tree to derive the final answer to the original question: A restaurant served 2384 customers in March, and 1869 customers in April. How many more customers were served in March than in April?",
                "Combination Output": "The number of customers served in March is 2384.\nThe number of customers served in April is 1869.\n2384 - 1869 = 515\nTherefore, the restaurant served 515 more customers in March than in April.",
                "Explanation": "The recursive decomposition prompting breaks down the problem into clear steps, solves each sub-problem, and combines the partial solutions to derive the final answer. In contrast, the baseline chain-of-thought prompting mixes the problem-solving steps together."
            },
            "Test Case 2": {
                "Question": "Megan is making a scarf. She bought 3 skeins of yarn. Each skein had 120 yards of yarn. She used 252 yards of yarn to make the scarf. How many yards of yarn does she have left?",
                "Baseline Prompt": "Megan is making a scarf. She bought 3 skeins of yarn. Each skein had 120 yards of yarn. She used 252 yards of yarn to make the scarf. How many yards of yarn does she have left?",
                "Baseline Output": "To find out how many yards of yarn Megan has left, I need to:\n1. Calculate the total yards of yarn she bought\n2. Subtract the yards used for the scarf from the total yards bought\n\nMegan bought 3 skeins, each with 120 yards.\nTotal yards = 3 \u00d7 120 = 360 yards\n\nShe used 252 yards for the scarf.\nYards left = 360 - 252 = 118 yards\n\nTherefore, Megan has 118 yards of yarn left.",
                "Decomposition Prompt": "Decompose the following question into sub-problems. Represent the decomposition as a tree where each node is a sub-problem. Format the tree as a nested bulleted list.\nQuestion: Megan is making a scarf. She bought 3 skeins of yarn. Each skein had 120 yards of yarn. She used 252 yards of yarn to make the scarf. How many yards of yarn does she have left?",
                "Decomposition Output": "- Find the total yards of yarn Megan bought\n  - Find the number of skeins Megan bought\n  - Find the yards of yarn in each skein\n  - Multiply the number of skeins by the yards per skein\n- Find the yards of yarn Megan used for the scarf\n- Subtract the yards used for the scarf from the total yards bought",
                "Recursive Solving Prompt 1": "Solve the sub-problem: Find the number of skeins Megan bought",
                "Recursive Solving Output 1": "Megan bought 3 skeins of yarn.",
                "Recursive Solving Prompt 2": "Solve the sub-problem: Find the yards of yarn in each skein",
                "Recursive Solving Output 2": "Each skein had 120 yards of yarn.",
                "Recursive Solving Prompt 3": "Solve the sub-problem: Multiply the number of skeins by the yards per skein",
                "Recursive Solving Output 3": "Total yards of yarn = 3 skeins \u00d7 120 yards/skein = 360 yards",
                "Recursive Solving Prompt 4": "Solve the sub-problem: Find the yards of yarn Megan used for the scarf",
                "Recursive Solving Output 4": "Megan used 252 yards of yarn to make the scarf.",
                "Recursive Solving Prompt 5": "Solve the sub-problem: Subtract the yards used for the scarf from the total yards bought",
                "Recursive Solving Output 5": "Yards of yarn left = 360 yards - 252 yards = 108 yards",
                "Combination Prompt": "Combine the sub-problem solutions based on the decomposition tree to derive the final answer to the original question: Megan is making a scarf. She bought 3 skeins of yarn. Each skein had 120 yards of yarn. She used 252 yards of yarn to make the scarf. How many yards of yarn does she have left?",
                "Combination Output": "Megan bought 3 skeins of yarn, each with 120 yards. So the total yards of yarn she bought is:\n3 skeins \u00d7 120 yards/skein = 360 yards\n\nShe used 252 yards of yarn to make the scarf.\n\nTo find the yards of yarn left, we subtract the used yards from the total yards:\n360 yards - 252 yards = 108 yards\n\nTherefore, Megan has 108 yards of yarn left.",
                "Explanation": "The recursive decomposition prompting clearly lays out each sub-problem and solves them step by step. It first finds the total yards bought by multiplying the number of skeins and yards per skein. Then it subtracts the used yards from the total. The baseline prompting mixes these steps together and is harder to follow."
            }
        },
        "Fallback Plan": "If the proposed recursive decomposition prompting does not outperform the baselines, we can conduct the following analyses to gain insights:\n1. Check the quality of the generated decomposition trees. Are the sub-problems reasonable and sufficient to solve the original problem? If not, the decomposition prompt may need improvement.\n2. Examine the sub-problem solutions. Are they correct? If not, the recursive solving prompt may be ineffective.\n3. Analyze the final answers after combination. Do the errors mainly come from incorrect decomposition, sub-problem solving, or combination? This can help identify the weak spot in the pipeline.\n4. Investigate the types of questions that the method fails on. Are there common patterns? This may inspire targeted improvements or reveal the method's limitations.\n5. Compare the reasoning steps taken by the proposed method and the baselines. Does recursive decomposition lead to more interpretable and reliable reasoning?\nBased on these analyses, we can either refine the prompts, modify the recursive solving process, or propose alternative methods. If the results are still unsatisfactory, we can focus on the insights gained from the analyses and turn the project into an informative failure report."
    }
}