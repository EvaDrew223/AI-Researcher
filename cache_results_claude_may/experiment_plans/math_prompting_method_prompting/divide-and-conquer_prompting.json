{
    "topic_description": "novel prompting methods for large language models to improve mathematical problem solving",
    "idea_name": "Divide-and-Conquer Prompting",
    "raw_idea": {
        "Problem": "Current language models can solve simple math problems, but struggle with problems that require complex problem decomposition and combining multiple reasoning steps. Flat chain-of-thought prompting works for simpler problems but cannot handle more complex problems.",
        "Existing Methods": "Datasets like MATH and MathQA test compositional mathematical reasoning, often with multiple problem-solving steps. Chain-of-thought prompting with self-consistency is a strong baseline.",
        "Motivation": "Many complex problems can be solved by recursively breaking them down into simpler subproblems, solving each subproblem, and composing the results. We draw inspiration from the divide-and-conquer paradigm in algorithm design, and hypothesize that we can elicit similar problem-solving behavior in language models through careful prompt design.",
        "Proposed Method": "We propose Divide-and-Conquer Prompting (DCP), where we prompt the model to decompose a complex problem into subproblems, then recursively apply the same decomposition to each subproblem until the subproblems are simple enough to be solved directly. The model is then prompted to compose the subproblem solutions into a final overall solution. The prompts encourage the model to explicitly state each decomposition and composition step in a hierarchical, recursive structure.",
        "Experiment Plan": "We will evaluate DCP on the MATH and MathQA benchmarks, comparing to chain-of-thought and self-consistency baselines. The key metric is problem-solving accuracy. We will also measure the complexity of the problem decompositions (average depth and branching factor) and correlate with accuracy. Qualitative analysis will examine the problem decomposition structure on representative examples."
    },
    "full_experiment_plan": {
        "Title": "Divide-and-Conquer Prompting: Recursive Problem Decomposition for Complex Reasoning in Language Models",
        "Problem Statement": "Current language models can solve simple math problems, but struggle with problems that require complex problem decomposition and combining multiple reasoning steps. Flat chain-of-thought prompting works for simpler problems but cannot handle more complex problems.",
        "Motivation": "Many complex problems can be solved by recursively breaking them down into simpler subproblems, solving each subproblem, and composing the results. This divide-and-conquer paradigm is widely used in algorithm design. We hypothesize that we can elicit similar problem-solving behavior in language models through careful prompt design, enabling them to tackle more complex reasoning problems. Existing methods like chain-of-thought prompting generate a flat sequence of reasoning steps, which is insufficient for problems with nested subproblems and recursive structure.",
        "Proposed Method": "We propose Divide-and-Conquer Prompting (DCP), where we prompt the model to decompose a complex problem into subproblems, then recursively apply the same decomposition to each subproblem until the subproblems are simple enough to be solved directly. The model is then prompted to compose the subproblem solutions into a final overall solution. The prompts encourage the model to explicitly state each decomposition and composition step in a hierarchical, recursive structure.",
        "Step-by-Step Experiment Plan": {
            "Step 1: Gather Datasets": "We evaluate DCP on the MATH and MathQA benchmarks, which test compositional mathematical reasoning, often with multiple problem-solving steps. These datasets contain a variety of problem types and difficulties.",
            "Step 2: Construct Prompts": "We compare DCP to several baselines: (1) direct prompting (only the question), (2) chain-of-thought prompting (\"Let's think step by step\"), and (3) self-consistency (using multiple samples). For DCP, we design a prompt template that encourages recursive problem decomposition and solution composition. The template includes: (1) a high-level description of the divide-and-conquer strategy, (2) an example demonstrating the recursive decomposition and composition steps, and (3) a prompt for the model to apply this strategy to the given problem. The model should output its reasoning in a hierarchical format, with each decomposition step numbered and indented.",
            "Step 3: Select Models": "We test the prompts on GPT-3.5 (text-davinci-002), GPT-4, and PaLM (palm-chat-bison-001). These models have shown strong performance on reasoning tasks.",
            "Step 4: Collect Results": "For each model and prompt, we generate solutions for all problems in the MATH and MathQA test sets. We compute the overall accuracy and compare the methods. We also measure the average depth and branching factor of the problem decompositions generated by DCP to quantify the structural complexity of the reasoning.",
            "Step 5: Analyze Results": "We compare the accuracy of DCP to the baselines and analyze whether the recursive decompositions correlate with improved performance. We also qualitatively examine the problem decomposition trees generated by DCP on representative examples to gain insights into its reasoning process."
        },
        "Test Case Examples": {
            "Baseline Prompt Input (Chain-of-Thought)": "Problem: A factory has 200 workers. 1/8 of the workers are working on product A, 1/4 on product B, and 1/2 on product C. The remaining workers are idle. How many workers are idle?\nLet's solve this step by step:",
            "Baseline Prompt Expected Output (Chain-of-Thought)": "Let's solve this step by step:\n1. Find the number of workers on product A: 1/8 of 200 = 200/8 = 25 workers\n2. Find the number of workers on product B: 1/4 of 200 = 200/4 = 50 workers\n3. Find the number of workers on product C: 1/2 of 200 = 200/2 = 100 workers\n4. Sum up the workers on products A, B, and C: 25 + 50 + 100 = 175 workers\n5. Subtract the total working from the total number of workers: 200 - 175 = 25 workers\nTherefore, 25 workers are idle.",
            "Proposed Prompt Input (DCP)": "Problem: A factory has 200 workers. 1/8 of the workers are working on product A, 1/4 on product B, and 1/2 on product C. The remaining workers are idle. How many workers are idle?\nSolve this problem using a divide-and-conquer approach. Decompose the problem into smaller subproblems, solve each subproblem recursively, and then compose the subproblem solutions into an overall solution. Show your work in a hierarchical format, with each decomposition step numbered and indented.",
            "Proposed Prompt Expected Output (DCP)": "Divide-and-conquer solution:\n1. Decompose the problem into subproblems\n   1.1. Find the number of workers on product A\n   1.2. Find the number of workers on product B\n   1.3. Find the number of workers on product C\n   1.4. Find the total number of working workers\n   1.5. Find the number of idle workers\n2. Solve each subproblem\n   2.1. Workers on product A\n        2.1.1. 1/8 of total workers = 200 \u00d7 1/8 = 25 workers\n   2.2. Workers on product B\n        2.2.1. 1/4 of total workers = 200 \u00d7 1/4 = 50 workers\n   2.3. Workers on product C\n        2.3.1. 1/2 of total workers = 200 \u00d7 1/2 = 100 workers\n   2.4. Total working workers\n        2.4.1. Sum subproblems 2.1, 2.2, and 2.3\n        2.4.2. 25 + 50 + 100 = 175 workers\n   2.5. Idle workers\n        2.5.1. Subtract subproblem 2.4 from total workers\n        2.5.2. 200 - 175 = 25 idle workers\n3. Compose the subproblem solutions\n   3.1. The number of idle workers is 25 (from subproblem 2.5)\nTherefore, 25 workers are idle.",
            "Explanation": "The chain-of-thought prompt generates a flat sequence of reasoning steps, while the DCP prompt encourages the model to explicitly decompose the problem into subproblems, solve them recursively, and compose the solutions. This hierarchical structure helps the model handle more complex problems by breaking them down into manageable parts."
        },
        "Fallback Plan": "If DCP does not outperform the baselines, we can analyze the generated problem decompositions to understand why. Potential issues could be: (1) the decompositions are not relevant or do not effectively simplify the problem, (2) the subproblem solutions are incorrect, or (3) the composition step fails to combine the subproblem solutions correctly. Based on this analysis, we can refine the prompt template to address the identified issues. If the refined prompts still do not yield improvements, we can pivot the project to focus on analyzing the limitations of recursive problem decomposition in language models and identifying problem types or structures that are particularly challenging for this approach. This analysis can provide valuable insights for future work on improving complex reasoning in language models."
    }
}